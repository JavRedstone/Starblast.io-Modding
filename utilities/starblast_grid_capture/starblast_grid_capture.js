var Rock_101 = '{"name":"Rock","level":1,"model":1,"size":2,"zoom":0.7,"specs":{"shield":{"capacity":[1000,1000],"reload":[0.1,0.1]},"generator":{"capacity":[150,150],"reload":[150,150]},"ship":{"mass":1000,"speed":[1,1],"rotation":[1000,1000],"acceleration":[1,1]}},"bodies":{"arm":{"section_segments":6,"angle":0,"offset":{"x":0,"y":0,"z":0},"position":{"x":[0,0,0,0,0,0,0,0,0,0,0],"y":[-90,-85,-70,-60,-10,10,60,70,85,90,85],"z":[0,0,0,0,0,0,0,0,0,0,0]},"width":[0,20,25,10,12,12,15,20,20,15,0],"height":[0,10,12,8,12,12,8,12,10,5,0],"texture":[2,1,12,2,4,2,12,16,17],"propeller":true},"cannon":{"section_segments":6,"offset":{"x":0,"y":-63,"z":0},"position":{"x":[0,0,0,0,0,0],"y":[-25,-30,-20,0,10,12],"z":[0,0,0,0,0,0]},"width":[0,5,5,7,6,0],"height":[0,5,5,7,6,0],"texture":[6,6,6,6,6],"laser":{"damage":[150,150],"rate":1,"type":1,"speed":[250,250],"number":1,"error":0}},"arm45":{"section_segments":6,"angle":45,"offset":{"x":0,"y":0,"z":0},"position":{"x":[0,0,0,0,0,0,0,0,0,0],"y":[-90,-85,-70,-60,-10,10,60,70,85,90],"z":[0,0,0,0,0,0,0,0,0,0]},"width":[0,20,25,10,12,12,10,25,20,0],"height":[0,10,12,8,12,12,8,12,10,0],"texture":[2,1,12,63,4,63,12,1,2]},"arm90":{"section_segments":6,"angle":90,"offset":{"x":0,"y":0,"z":0},"position":{"x":[0,0,0,0,0,0,0,0,0,0],"y":[-90,-85,-70,-60,-10,10,60,70,85,90],"z":[0,0,0,0,0,0,0,0,0,0]},"width":[0,20,25,10,12,12,10,25,20,0],"height":[0,10,12,8,12,12,8,12,10,0],"texture":[2,1,12,2,4,2,12,1,2]},"arm135":{"section_segments":6,"angle":-45,"offset":{"x":0,"y":0,"z":0},"position":{"x":[0,0,0,0,0,0,0,0,0,0],"y":[-90,-85,-70,-60,-10,10,60,70,85,90],"z":[0,0,0,0,0,0,0,0,0,0]},"width":[0,20,25,10,12,12,10,25,20,0],"height":[0,10,12,8,12,12,8,12,10,0],"texture":[2,1,12,63,4,63,12,1,2]}},"typespec":{"name":"Rock","level":1,"model":1,"code":101,"specs":{"shield":{"capacity":[1000,1000],"reload":[0.1,0.1]},"generator":{"capacity":[150,150],"reload":[150,150]},"ship":{"mass":1000,"speed":[1,1],"rotation":[1000,1000],"acceleration":[1,1]}},"shape":[3.724,3.541,3.474,1.242,3.349,3.52,3.6,3.568,3.485,3.01,3.164,3.5,3.598,3.6,3.5,3.164,3.01,3.485,3.568,3.6,3.52,3.349,1.515,3.502,3.637,3.607,3.637,3.502,1.515,3.349,3.52,3.6,3.568,3.485,3.01,3.164,3.5,3.598,3.6,3.5,3.164,3.01,3.485,3.568,3.6,3.52,3.349,1.242,3.474,3.541],"lasers":[{"x":0,"y":-3.72,"z":0,"angle":0,"damage":[150,150],"rate":1,"type":1,"speed":[250,250],"number":1,"spread":0,"error":0,"recoil":0}],"radius":3.724}}';
var Sniper_102 = '{"name":"Sniper","level":1,"model":2,"size":2,"zoom":0.7,"specs":{"shield":{"capacity":[1000,1000],"reload":[0.1,0.1]},"generator":{"capacity":[150,150],"reload":[75,75]},"ship":{"mass":1000,"speed":[1,1],"rotation":[1000,1000],"acceleration":[1,1]}},"bodies":{"main":{"section_segments":8,"offset":{"x":0,"y":-30,"z":5},"position":{"x":[0,0,0,0,0,0],"y":[0,-10,40,80,70,80],"z":[0,0,0,0,0,0]},"width":[0,10,15,10,0],"height":[0,5,23,10,0],"texture":[12,1,63,12],"propeller":true},"cockpit":{"section_segments":8,"offset":{"x":0,"y":-50,"z":25},"position":{"x":[0,0,0,0],"y":[20,40,80],"z":[-4,0,-6]},"width":[5,10,5],"height":[0,8,0],"texture":[9]},"wings":{"section_segments":8,"offset":{"x":15,"y":-20,"z":-10},"position":{"x":[0,0,0,0,0,0],"y":[-85,-95,50,60,50,60],"z":[0,0,0,0,0,0]},"width":[0,5,25,10,0],"height":[0,5,25,10,0],"texture":[12,2,3,4],"propeller":true},"cannons":{"section_segments":12,"offset":{"x":35,"y":-10,"z":-10},"position":{"x":[0,0,0,0,0,0,0],"y":[-60,-70,-20,0,20,30,25],"z":[0,0,0,0,0,0,0]},"width":[0,5,6,10,10,5,0],"height":[0,5,5,10,10,5,0],"angle":5,"laser":{"damage":[75,75],"rate":2,"type":1,"speed":[250,250],"number":1,"error":0},"texture":[3,1,63,3,12,2]}},"typespec":{"name":"Sniper","level":1,"model":2,"code":102,"specs":{"shield":{"capacity":[1000,1000],"reload":[0.1,0.1]},"generator":{"capacity":[150,150],"reload":[75,75]},"ship":{"mass":1000,"speed":[1,1],"rotation":[1000,1000],"acceleration":[1,1]}},"shape":[3.098,4.669,4.391,3.481,3.239,2.698,2.358,2.11,1.961,1.891,1.856,1.85,1.836,1.872,1.903,1.885,1.873,1.959,2,1.935,1.895,1.887,1.768,2.04,2.036,2.004,2.036,2.04,1.768,1.887,1.895,1.935,2,1.959,1.873,1.885,1.903,1.872,1.836,1.85,1.856,1.891,1.961,2.11,2.358,2.698,3.239,3.481,4.391,4.669],"lasers":[{"x":1.156,"y":-3.189,"z":-0.4,"angle":5,"damage":[75,75],"rate":2,"type":1,"speed":[250,250],"number":1,"spread":0,"error":0,"recoil":0},{"x":-1.156,"y":-3.189,"z":-0.4,"angle":-5,"damage":[75,75],"rate":2,"type":1,"speed":[250,250],"number":1,"spread":0,"error":0,"recoil":0}],"radius":4.669}}';
var Attacker_103 = '{"name":"Attacker","level":1,"model":3,"size":2,"zoom":0.7,"specs":{"shield":{"capacity":[1000,1000],"reload":[0.1,0.1]},"generator":{"capacity":[150,150],"reload":[37.5,37.5]},"ship":{"mass":1000,"speed":[1,1],"rotation":[1000,1000],"acceleration":[1,1]}},"bodies":{"main":{"section_segments":12,"offset":{"x":0,"y":0,"z":10},"position":{"x":[0,0,0,0,0,0,0,0],"y":[-90,-75,-50,0,80,105,90],"z":[0,0,0,0,0,0,0]},"width":[0,15,20,25,27,15,0],"height":[0,15,20,25,27,15,0],"propeller":true,"texture":[63,2,1,2,16,17]},"cockpit":{"section_segments":12,"offset":{"x":0,"y":-33,"z":20},"position":{"x":[0,0,0,0,0,0,0],"y":[-30,-10,10,30,60],"z":[0,0,0,0,0]},"width":[0,10,15,10,5],"height":[0,18,25,18,5],"propeller":false,"texture":9},"cannon":{"section_segments":6,"offset":{"x":0,"y":-60,"z":10},"position":{"x":[0,0,0,0,0,0],"y":[-40,-30,-20,-10,0,10],"z":[0,0,0,0,0,0]},"width":[0,5,5,5,5,5],"height":[0,5,5,5,5,5],"angle":0,"laser":{"damage":[37.5,37.5],"rate":4,"type":1,"speed":[250,250],"number":1,"error":1},"propeller":false,"texture":6}},"wings":{"end":{"length":[25,19],"width":[100,50,25],"angle":[0,45],"position":[70,75,80],"doubleside":true,"texture":[1,63],"bump":{"position":0,"size":0},"offset":{"x":20,"y":-20,"z":0}}},"typespec":{"name":"Attacker","level":1,"model":3,"code":103,"specs":{"shield":{"capacity":[1000,1000],"reload":[0.1,0.1]},"generator":{"capacity":[150,150],"reload":[37.5,37.5]},"ship":{"mass":1000,"speed":[1,1],"rotation":[1000,1000],"acceleration":[1,1]}},"shape":[4,3.391,3.074,2.398,1.926,1.611,1.387,1.243,1.144,1.081,1.034,1.005,0.998,1.007,1.041,1.279,1.676,2.449,3.203,3.663,3.725,3.724,3.871,4.079,4.243,4.208,4.243,4.079,3.871,3.724,3.725,3.663,3.203,2.449,1.676,1.279,1.041,1.007,1,1.005,1.034,1.081,1.144,1.243,1.387,1.611,1.926,2.398,3.074,3.391],"lasers":[{"x":0,"y":-4,"z":0.4,"angle":0,"damage":[37.5,37.5],"rate":4,"type":1,"speed":[250,250],"number":1,"spread":0,"error":1,"recoil":0}],"radius":4.243}}';

var ships = [
  Rock_101,
  Sniper_102,
  Attacker_103
];

this.options = {
  map_name: "Starblast Grid Capture",
  map_size: 30,
  custom_map: "",
  weapons_store: false,
  reset_tree: true,
  ships: ships,
  starting_ship: 801,
  radar_zoom: 1
};

var control = {
  teams: {
    length: 4,
    current: 0,
    colors: ["red", "yellow", "lime", "blue"],
    abbrev: ["R", "Y", "L", "B"],
    hues: [0, 60, 120, 240],
    scores: [0, 0, 0, 0]
  },
  dirs: {
    length: 4,
    tick: 20,
    names: ["left", "right", "up", "down"],
    values: ["ðŸ¡¸", "ðŸ¡º", "ðŸ¡¹", "ðŸ¡»"],
    shortcuts: ["A", "D", "W", "S"],
    list: []
  },
  map: {
    size: 0
  },
  ships: [101, 102, 103],
  tiles: {
    size: 20,
    base_spawn: [],
    tiles: [],
    types: [],
    colors: ["red", "yellow", "lime", "blue", "white", "magenta", "orchid", "grey", "brown"]
  },
  rounds: {
    num: 0,
    total: 50,
    tick: null,
    tickrate: 30,
    ship_msg_tickrate: 400,
    curr: null,
  },
  wait: {
    started: false,
    players: 1
  },
};

const white_tile = "https://raw.githubusercontent.com/JavRedstone/Starblast.io-Modding/main/utilities/starblast_grid_capture/White_Tile.png";
const red_tile = "https://raw.githubusercontent.com/JavRedstone/Starblast.io-Modding/main/utilities/starblast_grid_capture/Red_Tile.png";
const yellow_tile = "https://raw.githubusercontent.com/JavRedstone/Starblast.io-Modding/main/utilities/starblast_grid_capture/Yellow_Tile.png";
const lime_tile = "https://raw.githubusercontent.com/JavRedstone/Starblast.io-Modding/main/utilities/starblast_grid_capture/Lime_Tile.png";
const blue_tile = "https://raw.githubusercontent.com/JavRedstone/Starblast.io-Modding/main/utilities/starblast_grid_capture/Blue_Tile.png";

const goal_tile = "https://raw.githubusercontent.com/JavRedstone/Starblast.io-Modding/main/utilities/starblast_grid_capture/Goal_Tile.png";
const path_tile = "https://raw.githubusercontent.com/JavRedstone/Starblast.io-Modding/main/utilities/starblast_grid_capture/Path_Tile.png";
const disabled_path_tile = "https://raw.githubusercontent.com/JavRedstone/Starblast.io-Modding/main/utilities/starblast_grid_capture/Disabled_Path_Tile.png";

const block_tile = "https://raw.githubusercontent.com/JavRedstone/Starblast.io-Modding/main/utilities/starblast_grid_capture/Block_Tile.png";

control.tiles.types = [red_tile, yellow_tile, lime_tile, blue_tile, white_tile, goal_tile, path_tile, disabled_path_tile, block_tile];

class Tile {
  constructor ({
    id: id,
    type: image,
    position: { x: px, y: py },
  }) {
    this.id = id;
    this.type = {
      id: id,
      obj: 'https://starblast.data.neuronality.com/mods/objects/plane.obj',
      emissive: image
    };
    this.position = { x: px, y: py, z: -20 };
    this.rotation = { x: 0, y: Math.PI, z: Math.PI };
    this.scale = { x: control.tiles.size, y: control.tiles.size, z: 0 };
  }
  
  initiate () {
    game.setObject ({
      id: this.id,
      type: this.type,
      position: this.position,
      rotation: this.rotation,
      scale: this.scale 
    });
    
    control.tiles.tiles.push(this);
    return this;
  }
}

class Round {
  constructor() {
    this.tiles = [];
    this.captured = false;
  }
  
  start() {
    control.rounds.num++;
    return this;
  }
}

var center_tile, center_tile_left, center_tile_right, center_tile_up, center_tile_down, corner_tile_A, corner_tile_B, corner_tile_C, corner_tile_D;

function generate_stones () {
  // Create four center tiles in the same position for radar pos
  center_tile = new Tile ({
    id: "center_tile",
    type: block_tile,
    position: { x: control.map.size, y: control.map.size }
  }).initiate ();
  
  center_tile = new Tile ({
    id: "center_tile",
    type: block_tile,
    position: { x: -control.map.size, y: control.map.size }
  }).initiate ();
  
  center_tile = new Tile ({
    id: "center_tile",
    type: block_tile,
    position: { x: control.map.size, y: -control.map.size }
  }).initiate ();
  
  center_tile = new Tile ({
    id: "center_tile",
    type: block_tile,
    position: { x: -control.map.size, y: -control.map.size }
  }).initiate ();
  
  // Create the corner tiles
  corner_tile_A = new Tile ({
    id: "corner_tile_A",
    type: white_tile,
    position: { x: -control.map.size + control.tiles.size, y: control.map.size - control.tiles.size }
  }).initiate ();
  
  corner_tile_B = new Tile ({
    id: "corner_tile_B",
    type: white_tile,
    position: { x: control.map.size - control.tiles.size, y: control.map.size - control.tiles.size }
  }).initiate ();
  
  corner_tile_C = new Tile ({
    id: "corner_tile_C",
    type: white_tile,
    position: { x: control.map.size - control.tiles.size, y: -control.map.size + control.tiles.size }
  }).initiate ();
  
  corner_tile_D = new Tile ({
    id: "corner_tile_D",
    type: white_tile,
    position: { x: -control.map.size + control.tiles.size, y: -control.map.size + control.tiles.size }
  }).initiate ();
}

function check_there (pos) {
  for (var tile of control.tiles.tiles) {
    if (tile.position.x == pos.x && tile.position.y == pos.y && control.tiles.types.includes (tile.type.emissive)) {
      return true;
    }
  }
  return false;
}

function left (tile, image = white_tile, remove = false) {
  var pos = { x: tile.position.x - control.tiles.size, y: tile.position.y };
  return {
    check: check_there (pos),
    tile: !remove ? new Tile ({
      id: `tile_${pos.x}_${pos.y}`,
      type: image,
      position: pos
    }).initiate () : null
  };
}

function right (tile, image = white_tile, remove = false) {
  var pos = { x: tile.position.x + control.tiles.size, y: tile.position.y };
  return {
    check: check_there (pos),
    tile: !remove ? new Tile ({
      id: `tile_${pos.x}_${pos.y}`,
      type: image,
      position: pos
    }).initiate () : null
  };
}

function up (tile, image = white_tile, remove = false) {
  var pos = { x: tile.position.x, y: tile.position.y + control.tiles.size };
  return {
    check: check_there (pos),
    tile: !remove ? new Tile ({
      id: `tile_${pos.x}_${pos.y}`,
      type: image,
      position: pos
    }).initiate () : null
  };
}

function down (tile, image = white_tile, remove = false) {
  var pos = { x: tile.position.x, y: tile.position.y - control.tiles.size };
  return {
    check: check_there (pos),
    tile: !remove ? new Tile ({
      id: `tile_${pos.x}_${pos.y}`,
      type: image,
      position: pos
    }).initiate () : null
  };
}

control.dirs.list = [left, right, up, down];

function generate_border () {
  var curr_A = corner_tile_A;
  var curr_B = corner_tile_B;
  var curr_C = corner_tile_C;
  var curr_D = corner_tile_D;
  
  for (let i = 0; i < control.map.size * 2 / control.tiles.size - 3; i++) {
    curr_A = right (curr_A).tile;
    curr_B = down (curr_B).tile;
    curr_C = left (curr_C).tile;
    curr_D = up (curr_D).tile;
  }
}

function generate_bases () {
  control.tiles.base_spawn[0] = right (right (corner_tile_A).tile).tile;
  control.tiles.base_spawn[1] = down (down (corner_tile_B).tile).tile;
  control.tiles.base_spawn[2] = left (left (corner_tile_C).tile).tile;
  control.tiles.base_spawn[3] = up (up (corner_tile_D).tile).tile;
  
  for (let i = 0; i < 3; i++) {
    control.tiles.base_spawn[0] = down (control.tiles.base_spawn[0], red_tile).tile;
    control.tiles.base_spawn[1] = left (control.tiles.base_spawn[1], yellow_tile).tile;
    control.tiles.base_spawn[2] = up (control.tiles.base_spawn[2], lime_tile).tile;
    control.tiles.base_spawn[3] = right (control.tiles.base_spawn[3], blue_tile).tile;
  }
}

function get_base_pos (team) {
  return { x: control.tiles.base_spawn[team].position.x, y: control.tiles.base_spawn[team].position.y };
}

function generate_dirs (ship) {
  for (let i = 0; i < control.dirs.length; i++) {
    ship.setUIComponent ({
      id: control.dirs.names[i],
      position: [60 + i * 4, 1, 4, 6.4],
      clickable: ship.custom.rest[i].clickable,
      shortcut: `${control.dirs.shortcuts[i]}`,
      components: [
        { type: "box", position: [0,0,100,100], stroke: ship.custom.rest[i].stroke, width: 2},
        { type: "text", position: [5, 10, 90, 60], value: control.dirs.values[i], color: ship.custom.rest[i].color},
        { type: "text", position: [5, 65, 90, 25], value: `[${control.dirs.shortcuts[i]}]`, color: ship.custom.rest[i].color}
      ]
    });
  }
}

function enable_dir (dir, ship) {
   ship.custom.rest[dir] = {
    clickable: true,
    stroke: "white",
    color: "white"
  };
  
  generate_dirs (ship);
}

function disable_dir (dir, ship) {
   ship.custom.rest[dir] = {
    clickable: false,
    stroke: "grey",
    color: "grey"
  };
  
  generate_dirs (ship);
}

function generate_team (ship) {
  var team_color = control.teams.colors[ship.custom.team];
  var team_abbrev = control.teams.abbrev[ship.custom.team];
  var team_hue = control.teams.hues[ship.custom.team];

  ship.setUIComponent({
    id: "team",
    position: [76, 1, 4, 6.4],
    components: [
      { type: "box", position: [0,0,100,100], stroke: team_color, width: 2},
      { type: "text", position: [5, 10, 90, 60], value: team_abbrev, color: team_color},
      { type: "text", position: [5, 65, 90, 25], value: `[${team_color.toUpperCase ()}]`, color: team_color}
    ]
  });
}

function generate_scoreboard (ship) {
  var scoreboard = {
    id: "scoreboard",
    components: [
      {
        type: "box",
        position: [0, 75, 100, 15],
        stroke: "magenta",
        width: 3
      },
      {
        type: "text",
        position: [0, 75, 50, 15],
        value: "ROUND:",
        color: "magenta",
        align: "left"
      },
      {
        type: "text",
        position: [0, 75, 100, 15],
        value: control.rounds.num,
        color: "magenta",
        align: "right"
      }  
    ]
  };
  
  for (let i = 0; i < control.teams.length; i++) {
    scoreboard.components.push (
      {
        type: "box",
        position: [0, i * 15, 100, 15],
        fill: ship.custom.team == i ? "rgba(0, 255, 255, 0.2)" : "rgba(0, 0, 0, 0)",
        stroke: control.teams.colors[i],
        width: 3
      },
      {
        type: "text",
        position: [0, i * 15, 50, 15],
        value: `${control.teams.colors[i].toUpperCase ()}:`,
        color: control.teams.colors[i],
        align: "left"
      },
      {
        type: "text",
        position: [0, i * 15, 100, 15],
        value: control.teams.scores[i],
        color: control.teams.colors[i],
        align: "right"
      }
    );
  }
  
  ship.setUIComponent (scoreboard);
}


function generate_tile_radar () {
  var scale_pos = 100 / (game.options.map_size * 10);
  var scale_size = 25 / game.options.map_size;
  
  var tile_radar = {
    id: "radar_background",
    components: []
  };
  
  for (var tile of control.tiles.tiles) {
    tile_radar.components.push (
      {
        type: "box",
        position: [
          47.5 + tile.position.x * scale_pos - control.tiles.size * scale_size / 10,
          47.5 - tile.position.y * scale_pos - control.tiles.size * scale_size / 10,
          control.tiles.size * scale_size / 2.5,
          control.tiles.size * scale_size / 2.5
        ],
        stroke: control.tiles.colors[control.tiles.types.indexOf (tile.type.emissive)],
        width: 2
      }
    );
  }
  
  game.setUIComponent (tile_radar);
}

function generate_message (message, ship, color = "rgb(128, 181, 233)", pos = [0, 10, 100, 5]) {
  ship.setUIComponent ({
    id: `message_${pos[0]}_${pos[1]}_${pos[2]}_${pos[3]}`,
    position: pos,
    visible: true,
    components: [
      {
        type: "text",
        position: [0, 0, 100, 100],
        value: message,
        color: color
      }
    ]
  });
}

function hide_message (ship, pos = [0, 10, 100, 5]) {
  ship.setUIComponent ({
    id: `message_${pos[0]}_${pos[1]}_${pos[2]}_${pos[3]}`,
    visible: false,
  });
}

function update_dirs (ship) {
  ship.custom.left = { x: ship.custom.pos.x - control.tiles.size, y: ship.custom.pos.y };
  ship.custom.right = { x: ship.custom.pos.x + control.tiles.size, y: ship.custom.pos.y };
  ship.custom.up = { x: ship.custom.pos.x, y: ship.custom.pos.y + control.tiles.size };
  ship.custom.down = { x: ship.custom.pos.x, y: ship.custom.pos.y - control.tiles.size };
  
  ship.custom.left_avail = false;
  ship.custom.right_avail = false;
  ship.custom.up_avail = false;
  ship.custom.down_avail = false;
  
  if (check_there (ship.custom.left)) ship.custom.left_avail = true;
  if (check_there (ship.custom.right)) ship.custom.right_avail = true;
  if (check_there (ship.custom.up)) ship.custom.up_avail = true;
  if (check_there (ship.custom.down)) ship.custom.down_avail = true;
  
  ship.custom.left_avail ? enable_dir (0, ship) : disable_dir (0, ship);
  ship.custom.right_avail ? enable_dir (1, ship) : disable_dir (1, ship);
  ship.custom.up_avail ? enable_dir (2, ship) : disable_dir (2, ship);
  ship.custom.down_avail ? enable_dir (3, ship) : disable_dir (3, ship);
}

this.tick = function (game) {
  switch (true) {
    case game.step === 0:
      control.map.size = game.options.map_size * 5;
      
      generate_stones ();
      
      generate_border ();
      
      generate_bases ();
      break;
    case game.step % control.dirs.tick === 0:
      for (var ship of game.ships) {
        if (ship.custom.pos) {
          ship.set ({
            x: ship.custom.pos.x,
            y: ship.custom.pos.y,
            vx: 0,
            vy: 0
          });
        }
        
        generate_scoreboard (ship);
        
        switch (control.wait.started) {
          case true:
            update_dirs (ship);
            
            if (control.rounds.curr && control.rounds.curr.tiles[0].position.x == ship.custom.pos.x && control.rounds.curr.tiles[0].position.y == ship.custom.pos.y) {
              for (var _ship of game.ships) {
                _ship.custom.pos = get_base_pos (_ship.custom.team);
                generate_message (`${ship.name} from ${control.teams.colors[ship.custom.team].toUpperCase ()} team has scored a point!`, _ship, control.teams.colors[ship.custom.team]);
                _ship.custom.msg_tick = game.step;
              }
              
              control.teams.scores[ship.custom.team] += 1;
              control.rounds.curr.captured = true;
              
              if (control.rounds.num == control.rounds.total) {
                generate_message (`${control.rounds.total} rounds have been reached! Good game!`, ship, "magenta", [0, 16, 100, 10]);
                ship.custom.rmsg_tick = game.step;
              }
            }
            
            if (ship.custom.msg_tick && game.step - ship.custom.msg_tick == control.rounds.ship_msg_tickrate) {
              hide_message (ship);
            }
            
            if (ship.custom.rmsg_tick && game.step - ship.custom.rmsg_tick == control.rounds.ship_msg_tickrate) {
              hide_message (ship, [0, 16, 100, 10]);
              
              if (control.rounds.num == control.rounds.total) {
                ship.gameover ({
                  "Team": control.teams.colors[ship.custom.team].toUpperCase (),
                  "Points": control.teams.scores[ship.custom.team]
                });
              }
            }
            break;
          case false:
            if (game.ships.length >= control.wait.players) {
              for (var _ship of game.ships) {
                hide_message (_ship);
              }
              
              control.wait.started = true;
            }
            
            else {
              generate_message (`Waiting for more players... â€” ${control.wait.players - game.ships.length} player(s) remaining.`, ship);
            }
            break;
        }
      }
      
      generate_tile_radar ();
      
      if (control.wait.started) {
        if (!control.rounds.tick) {
          control.rounds.tick = game.step;
        }
        
        else if (game.step - control.rounds.tick >= control.rounds.tickrate || control.rounds.curr.captured) {
          if (control.rounds.curr) {
            for (var tile of control.rounds.curr.tiles) {
              game.removeObject (tile.id);
              new Tile ({
                id: `disabled_path_${tile.id}`,
                type: disabled_path_tile,
                position: tile.position
              }).initiate ();
            }
            
            control.rounds.curr = null;
          }
          
          if (control.rounds.num < control.rounds.total) {
            control.rounds.curr = new Round ().start ();
            
            for (var ship of game.ships) {
              generate_message (`Round ${control.rounds.num} has started!`, ship, "magenta", [0, 16, 100, 10]);
              ship.custom.rmsg_tick = game.step;
            }
            
            var goal_pos;
            
            generate_goal_pos ();
            
            function generate_goal_pos () {
              goal_pos = {
                x: control.tiles.size * (Math.floor(Math.random() * (control.map.size / control.tiles.size))) * (Math.round(Math.random()) === 0 ? -1 : 1) + ((game.options.map_size / 10) % 2 === 0 ? 0 : control.tiles.size / 2),
                y: control.tiles.size * (Math.floor(Math.random() * (control.map.size / control.tiles.size))) * (Math.round(Math.random()) === 0 ? -1 : 1) + ((game.options.map_size / 10) % 2 === 0 ? 0 : control.tiles.size / 2)
              }
              
              if (check_there (goal_pos)) {
                return generate_goal_pos ();
              }
            }
            
            var goal = new Tile ({
              id: `${control.rounds.num}_goal_tile`,
              type: goal_tile,
              position: goal_pos
            }).initiate ();
            
            control.rounds.curr.tiles.push (goal);
              
            generate_goal_path ();
            
            function generate_goal_path () {
              
              var dir_link = control.dirs.list[Math.round (Math.random () * (control.dirs.list.length - 1))];
              
              var path = goal;
              
              let i = 0;
              while (true) {
                if (dir_link (path, white_tile, true).check) {
                  break;
                }
                
                else {
                  path = dir_link (path, path_tile).tile;
                  control.rounds.curr.tiles.push (path);
                }
                i++;
                if (i > control.map.size * 2 / control.tiles.size - 3) {
                  for (var tile of control.rounds.curr.tiles) {
                    game.removeObject (tile.id);
                    control.rounds.curr.tiles.splice (control.rounds.curr.tiles.indexOf (tile), 1);
                    control.tiles.tiles.splice (control.tiles.tiles.indexOf (tile), 1);
                  }
                  return generate_goal_path ();
                }
              }
            }
          }
          
          control.rounds.tick = null;
        }
      }
      break;
  }
};

this.event = function (event, game) {
  var ship = event.ship;
  switch (event.name) {
    case "ship_spawned":
      ship.custom.rest = [];
      for (let i = 0; i < control.dirs.length; i++) {
        ship.custom.rest.push ({
          clickable: false,
          stroke: "grey",
          color: "grey"
        });
      }
      
      if (!ship.custom.spawned) {
        generate_dirs (ship);
        
        generate_scoreboard (ship);
        
        ship.custom.team = control.teams.current;
        control.teams.current = control.teams.current < control.teams.length - 1 ? control.teams.current + 1 : 0;
        generate_team (ship);
        
        ship.set ({
          hue: control.teams.hues[ship.custom.team],
          type: control.ships[Math.round (Math.random () * (control.ships.length - 1))]
        });
        
        ship.custom.spawned = true;
      }
      
      ship.custom.pos = get_base_pos (ship.custom.team);
      break;
    case "ui_component_clicked":
      if (!ship.custom.ui_tick || game.step - ship.custom.ui_tick >= control.dirs.tick) {
        ship.custom.ui_tick = game.step;
        switch (event.id) {
          case "left":
            if (ship.custom.left_avail) ship.custom.pos.x -= control.tiles.size;
            break;
          case "right":
            if (ship.custom.right_avail) ship.custom.pos.x += control.tiles.size;
            break;
          case "up":
            if (ship.custom.up_avail) ship.custom.pos.y += control.tiles.size;
            break;
          case "down":
            if (ship.custom.down_avail) ship.custom.pos.y -= control.tiles.size;
            break;
        }
      }
      break;
  }
};
